# gradle 多渠道打包二

## gradle 执行流程
1.初始化阶段，解析setting.gradle,构建所有Project对应的Project对象
2.配置阶段，解析所有Project对象中的task，生成所有task的拓扑图，这里并不会执行task
3.执行阶段，执行具体的task及其依赖task。
project中build.gradle解析的顺序和settings.gradle中设置的顺序没有关系，和所处项目的位置有关系，它是按照项目
中的顺序进行解析的。

## Project声明周期回调方法
Project 提供的生命周期回调方法有：
```Groovy
//在 Project 进行配置前调用
void beforeEvaluate(Closure closure)
//在 Project 配置结束后调用
void afterEvaluate(Closure closure)
```
beforeEvaluate 必须在父模块的 build.gradle 对子模块进行配置才能生效，因为在当前模块的 build.gradle 中配置，  
它自己本身都没配置好，所以不会监听到。

在根目录build.gradle添加以下代码：
```Groovy
//对子模块进行配置
subprojects { sub ->
    sub.beforeEvaluate { proj ->
        println "子项目 ${proj.getName()} beforeEvaluate回调..."
    }
}

println "根项目配置开始---"

task rootTest {
    println "根项目里任务配置---"
    doLast {
        println "执行根项目任务..."
    }
}

println "根项目配置结束---"
```
```Groovy
println "APP子项目配置开始---"

afterEvaluate {
    println "APP子项目afterEvaluate回调..."
}

task appTest {
    println "APP子项目里任务配置---"
    doLast {
        println "执行子项目任务..."
    }
}

println "APP子项目配置结束---"
```
运行gradlew -q，输出结果：
```Groovy
根项目配置开始---
根项目里任务配置---
根项目配置结束---
子项目 app beforeEvaluate回调...
========================
这是个插件!
========================
APP子项目配置开始---
APP子项目里任务配置---
APP子项目配置结束---
APP子项目afterEvaluate回调...
```

## gradle声明周期方法
gradle声明周期方法主要有：
```Groovy
//在project进行配置前调用，child project必须在root project中设置才会生效，root project必须在settings.gradle中设置才会生效
void beforeProject(Closure closure)

//在project配置后调用
afterProject(Closure closure)

//构建开始前调用
void buildStarted(Closure closure)

//构建结束后调用
void buildFinished(Closure closure)

//所有project配置完成后调用
void projectsEvaluated(Closure closure)

//当settings.gradle中引入的所有project都被创建好后调用，只在该文件设置才会生效
void projectsLoaded(Closure closure)

//settings.gradle配置完后调用，只对settings.gradle设置生效
void settingsEvaluated(Closure closure)
```

在项目的settings.gradle最前面添加测试代码：
```Groovy
gradle.settingsEvaluated {
    println "=============================> settings：执行settingsEvaluated...  settings.gradle配置完后调用，只对settings.gradle设置生效"
}

gradle.projectsLoaded {
    println "=============================> settings：执行projectsLoaded...  当settings.gradle中引入的所有project都被创建好后调用，只在该文件设置才会生效"
}

gradle.projectsEvaluated {
    println "=============================> settings: 执行projectsEvaluated...  所有project配置完成后调用"
}

gradle.beforeProject { proj ->
    println "=============================> settings：执行${proj.name} beforeProject...  在project进行配置前调用，child project必须在root project中设置才会生效，root project必须在settings.gradle中设置才会生效"
}

gradle.afterProject { proj ->
    println "=============================> settings：执行${proj.name} afterProject...  在project配置后调用"
}

gradle.buildStarted {
    println "=============================> 构建开始... 构建开始前调用"
}

gradle.buildFinished {
    println "=============================> 构建结束... 构建结束后调用"
}

include ':module1', ':app', ':module2', ':buildSrc'
```
运行gradle -q，输出结果：
=============================> settings：执行settingsEvaluated...  settings.gradle配置完后调用，只对settings.gradle设置生效
=============================> settings：执行projectsLoaded...  当settings.gradle中引入的所有project都被创建好后调用，只在该文件设置才会生效
=============================> settings：执行Gradle beforeProject...  在project进行配置前调用，child project必须在root project中设置才会生效，root project必须在settings.gradle中设置才会生效
=============================> settings：执行Gradle afterProject...  在project配置后调用
=============================> settings：执行app beforeProject...  在project进行配置前调用，child project必须在root project中设置才会生效，root project必须在settings.gradle中设置才会生效
=============================> settings：执行app afterProject...  在project配置后调用
=============================> settings：执行buildSrc beforeProject...  在project进行配置前调用，child project必须在root project中设置才会生效，root project必须在settings.gradle中设置才会生效
=============================> settings：执行buildSrc afterProject...  在project配置后调用
=============================> settings：执行module1 beforeProject...  在project进行配置前调用，child project必须在root project中设置才会生效，root project必须在settings.gradle中设置才会生效
=============================> settings：执行module1 afterProject...  在project配置后调用
=============================> settings：执行module2 beforeProject...  在project进行配置前调用，child project必须在root project中设置才会生效，root project必须在settings.gradle中设置才会生效
=============================> settings：执行module2 afterProject...  在project配置后调用
=============================> settings: 执行projectsEvaluated...  所有project配置完成后调用
=============================> 构建结束... 构建结束后调用

## TaskExecutionGraph（Task执行图）
Gradle 在配置完成后，会对所有的 task 生成一个有向无环图，这里叫做 task 执行图，他们决定了 task 的执行顺序等。  
同样，Gradle 可以对 task 的执行生命周期进行监听。
```Groovy
//任务执行前掉用
void afterTask​(Closure closure)
//任务执行后调用
void beforeTask(Closure closure)
//任务准备好后调用
void whenReady(Closure closure)
```
通过 gradle.getTaskGraph() 方法来获取 task 执行图：
```Groovy
TaskExecutionGraph taskGraph = gradle.getTaskGraph()
taskGraph.whenReady {
    println "=============================> task whenReady"
}

taskGraph.beforeTask { Task task ->
    println "=============================> 任务名称：${task.name} beforeTask"
}

taskGraph.afterTask { Task task ->
    println "=============================> 任务名称：${task.name} afterTask"
}
```

## 生命周期回调的执行顺序总结：
```Groovy
gradle.settingsEvaluated->
gradle.projectsLoaded->
gradle.beforeProject->
project.beforeEvaluate->
gradle.afterProject->
project.afterEvaluate->
gradle.projectsEvaluated->
gradle.taskGraph.graphPopulated->
gradle.taskGraph.whenReady->
gradle.buildFinished
```












